{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Team 9964A Description","text":""},{"location":"#choices","title":"Choices","text":"<p>The biggest decision that was made on the programming side of our team was to switch to PROS from VEXCode.</p> <p>The creators of VEX created VEXCode, a programming environment that uses a language derived from C++, dedicated for use with VEX hardware. Since VEX is often seen as a pathway into engineering or programming, the creators removed support for many C++ features, making the language much easier to learn at the expense of certain functionalities.</p> <p>As the programmers of the team, we knew that VEXCode limited our capabilities when it came to programming.</p> <p>This is where PROS comes in. The developers of PROS, the Purdue SigBots, decided that while the VEXCode environment was good for beginners, more advanced users should be allowed to use all of the features that make C++ one of the fastest languages. Along with this, they added a library named OkapiLib, including functionality for prepackaged functions that enable teams to implement advanced processes such as odometry and PID, two essential features that are needed for a high-level team to succeed.</p> PROS VEXCode Pros  Faster, More features Easier to learn and use Cons  Harder to learn Slower and less functionality <p>Since we, the programmers of this team, are relatively experienced in programming, we decided that it would be best to utilize the option with more functionality which was PROS.</p>"},{"location":"design/","title":"Design Choices","text":"<p>The engineering design choice</p>"},{"location":"docs/","title":"Docs","text":""},{"location":"docs/#program-documentation","title":"Program Documentation","text":"Main ProgramVariablesFunctionsFunctions Header main.cpp<pre><code>#include \"functions.hpp\"\n#include \"okapi/api/util/logging.hpp\"\n#include \"okapi/impl/chassis/controller/chassisControllerBuilder.hpp\"\n#include \"robot.hpp\"\n// defining the controller\npros::Controller prosController(pros::E_CONTROLLER_MASTER);\n// initialize pneumatic pistons\npros::ADIDigitalOut leftPiston(LEFT_DIGITAL_SENSOR_PORT);\npros::ADIDigitalOut rightPiston(RIGHT_DIGITAL_SENSOR_PORT);\npros::ADIDigitalOut catapultLock(CATAPULT_DIGITAL_SENSOR_PORT);\npros::ADIDigitalOut jerry(EXTENSION_DIGITAL_SENSOR_PORT);\n// initialize limit switch for catapult windback\npros::ADIDigitalIn windbackLimit(PULLLIMIT_DIGITAL_SENSOR_PORT);\n// defining the PTO motors\npros::Motor lUFM(LEFT_DRIVE_MOTOR3_PORT, PROS_DRIVE_GEARSET, 0,\nPROS_DRIVE_MEASURE);\npros::Motor rUFM(RIGHT_DRIVE_MOTOR3_PORT, PROS_DRIVE_GEARSET, 1,\nPROS_DRIVE_MEASURE);\n// defining the rest of the motors\npros::Motor lUBM(LEFT_DRIVE_MOTOR4_PORT, PROS_DRIVE_GEARSET, 0,\nPROS_DRIVE_MEASURE);\npros::Motor rUBM(RIGHT_DRIVE_MOTOR4_PORT, PROS_DRIVE_GEARSET, 1,\nPROS_DRIVE_MEASURE);\npros::Motor lLFM(LEFT_DRIVE_MOTOR1_PORT, PROS_DRIVE_GEARSET, 0,\nPROS_DRIVE_MEASURE);\npros::Motor rLFM(RIGHT_DRIVE_MOTOR1_PORT, PROS_DRIVE_GEARSET, 1,\nPROS_DRIVE_MEASURE);\npros::Motor lLBM(LEFT_DRIVE_MOTOR2_PORT, PROS_DRIVE_GEARSET, 0,\nPROS_DRIVE_MEASURE);\npros::Motor rLBM(RIGHT_DRIVE_MOTOR2_PORT, PROS_DRIVE_GEARSET, 1,\nPROS_DRIVE_MEASURE);\n// defining the drivetrain motors\npros::Motor_Group prosLDM({LEFT_DRIVE_MOTOR1_PORT, LEFT_DRIVE_MOTOR2_PORT,\nLEFT_DRIVE_MOTOR4_PORT});\npros::Motor_Group prosRDM({RIGHT_DRIVE_MOTOR1_PORT, RIGHT_DRIVE_MOTOR2_PORT,\nRIGHT_DRIVE_MOTOR4_PORT});\n// motors not included: LEFT_DRIVE_MOTOR3_PORT, RIGHT_DRIVE_MOTOR3_PORT\n// defining the drivetrain motors for odometry\n// PTO motors are omitted for simplicity\nokapi::MotorGroup okapiLDM({LEFT_DRIVE_MOTOR1_PORT, LEFT_DRIVE_MOTOR2_PORT,\nLEFT_DRIVE_MOTOR4_PORT});\nokapi::MotorGroup okapiRDM({RIGHT_DRIVE_MOTOR1_PORT, RIGHT_DRIVE_MOTOR2_PORT,\nRIGHT_DRIVE_MOTOR4_PORT});\nokapi::Motor rMotor(RIGHT_DRIVE_MOTOR3_PORT, true, OKAPI_DRIVE_GEARSET,\nOKAPI_DRIVE_MEASURE);\nokapi::Motor lMotor(LEFT_DRIVE_MOTOR3_PORT, false, OKAPI_DRIVE_GEARSET,\nOKAPI_DRIVE_MEASURE);\n// defining the okapi chassis object\nstd::shared_ptr&lt;okapi::OdomChassisController&gt; chassis =\nokapi::ChassisControllerBuilder()\n.withMotors(okapiLDM, // left motors\nokapiRDM  // right motors\n)\n.withDimensions(\n{\nOKAPI_DRIVE_GEARSET, // drive gearset stored in robot.h\n(DRIVE_GEARWHEEL / DRIVE_GEARMOTOR) // drivetrain gearing\n},\n{\n{\nCHASSIS_WHEELS, // wheel size stored in robot.h\nCHASSIS_TRACK   // drivetrain track size (length between\n// wheels on same axis) stored in robot.h\n},\nOKAPI_DRIVE_TPR // drivetrain ticks per rotation stored in\n// robot.h\n})\n.withOdometry()\n.buildOdometry();\n/*\nstd::shared_ptr&lt;okapi::ChassisController&gt; driveController =\n    okapi::ChassisControllerBuilder()\n        .withMotors(okapiLDM, // left motors\n                    okapiRDM  // right motors\n                    )\n        .withDimensions(\n            {\n                OKAPI_DRIVE_GEARSET, // drive gearset stored in robot.h\n                (DRIVE_GEARWHEEL / DRIVE_GEARMOTOR) // drivetrain gearing\n            },\n            {\n                {\n                    CHASSIS_WHEELS, // wheel size stored in robot.h\n                    CHASSIS_TRACK   // drivetrain track size (length between\n                                    // wheels on same axis) stored in robot.h\n                },\n                OKAPI_DRIVE_TPR // drivetrain ticks per rotation stored in\n                                // robot.h\n            })\n        .withOdometry()\n        .buildOdometry();\nstd::shared_ptr&lt;okapi::AsyncPositionController&lt;double, double&gt;&gt; cataController =\n    okapi::AsyncPosControllerBuilder()\n        .withMotor({lMotor, rMotor})\n        .withGains({0.001, 0.0001, 0.0001})\n        .build();*/\n// boolean value for PTO activation state\nbool ptoActivated = false;\nbool extensionActivated = true;\n// boolean value for windback process\nbool windingBack = false;\n// boolean value for intake toggle state\nbool intakeActivated = false;\n/**\n * Runs initialization code. This occurs as soon as the program is started.\n *\n * All other competition modes are blocked by initialize; it is recommended\n * to keep execution time for this mode under a few seconds.\n */\nvoid initialize() {\n// creates buttons on the cortex lcd display\n// pros::lcd::initialize();\nprosRDM.set_reversed(true);\nprosLDM.set_gearing(PROS_DRIVE_GEARSET);\nprosRDM.set_gearing(PROS_DRIVE_GEARSET);\nrightPiston.set_value(ptoActivated);\nleftPiston.set_value(ptoActivated);\njerry.set_value(extensionActivated);\n}\n/**\n * Runs while the robot is in the disabled state of Field Management System or\n * the VEX Competition Switch, following either autonomous or opcontrol. When\n * the robot is enabled, this task will exit.\n */\nvoid disabled() {}\n/**\n * Runs after initialize(), and before autonomous when connected to the Field\n * Management System or the VEX Competition Switch. This is intended for\n * competition-specific initialization routines, such as an autonomous selector\n * on the LCD.\n *\n * This task will exit when the robot is enabled and autonomous or opcontrol\n * starts.\n */\nvoid competition_initialize() {}\n/**\n * Runs the user autonomous code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the autonomous\n * mode. Alternatively, this function may be called in initialize or opcontrol\n * for non-competition testing purposes.\n *\n * If the robot is disabled or communications is lost, the autonomous task\n * will be stopped. Re-enabling the robot will restart the task, not re-start it\n * from where it left off.\n */\nvoid autonomous() {\n// setting the default values for the odometry\n// our team uses a placement guide so this number stays consistent\nchassis-&gt;setState({0_in, 0_in});\nchassis-&gt;turnAngle(45_deg);\nchassis-&gt;turnAngle(45_deg);\nchassis-&gt;driveToPoint({0_in, 6_in}, false, 0_in);\n}\n/**\n * Runs the operator control code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the operator\n * control mode.\n *\n * If no competition control is connected, this function will run immediately\n * following initialize().\n *\n * If the robot is disabled or communications is lost, the\n * operator control task will be stopped. Re-enabling the robot will restart the\n * task, not resume it from where it left off.\n */\nvoid opcontrol() {\n// main while loop\nwhile (true) {\n// sets the speed of the drivetrain motors according to the controller\n// joystick positions ranges -127 to 127\nupdate_drivetrain();\n// extension\nextension();\n// roller mech\nroll_roller();\n// temperature rumble\n// temp_rumble();\n// final delay\n// lUFM = prosController.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);\n// rUFM = prosController.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_Y);\npros::delay(20);\n}\n}\n</code></pre> robot.hpp<pre><code>#pragma once // prevents the file from being included multiple times\n#include &lt;memory&gt;\n// includes all needed files\n#include \"functions.hpp\"\n#include \"main.h\"\n#include \"okapi/api/chassis/controller/chassisControllerIntegrated.hpp\"\n#include \"okapi/api/chassis/controller/odomChassisController.hpp\"\n#include \"okapi/api/chassis/model/chassisModel.hpp\"\n#include \"okapi/api/device/motor/abstractMotor.hpp\"\n#include \"okapi/api/units/QLength.hpp\"\n#include \"okapi/api/units/RQuantity.hpp\"\n#include \"okapi/api/util/logging.hpp\"\n#include \"okapi/api/util/mathUtil.hpp\"\n#include \"okapi/impl/chassis/controller/chassisControllerBuilder.hpp\"\n#include \"okapi/impl/device/motor/motorGroup.hpp\"\n#include \"pros/adi.h\"\n#include \"pros/adi.hpp\"\n#include \"pros/misc.h\"\n#include \"pros/motors.h\"\n#include \"pros/rtos.hpp\"\n// global\n// stores motor port values\n// motor 3 on both sides is attached to the PTO\n#define RIGHT_DRIVE_MOTOR1_PORT 1\n#define RIGHT_DRIVE_MOTOR2_PORT 2\n#define RIGHT_DRIVE_MOTOR3_PORT 3\n#define RIGHT_DRIVE_MOTOR4_PORT 4\n#define LEFT_DRIVE_MOTOR1_PORT 5\n#define LEFT_DRIVE_MOTOR2_PORT 6\n#define LEFT_DRIVE_MOTOR3_PORT 7 // roller mech motor\n#define LEFT_DRIVE_MOTOR4_PORT 8\nextern int RIGHT_DRIVE_MOTOR_PORTS[4];\n// stores the gearing of the drivetrain\n#define OKAPI_DRIVE_GEARSET                                                    \\\n  okapi::AbstractMotor::gearset::blue // blue motor RPM (600)\n#define OKAPI_DRIVE_TPR                                                        \\\n  okapi::imev5BlueTPR // gear ticks per rotation in a blue motor cartridge\n#define DRIVE_GEARMOTOR                                                        \\\n  36.0 // gear tooth count on the axle attached to the motor\n#define DRIVE_GEARWHEEL                                                        \\\n  60.0 // gear tooth count on the axle attached to the wheel\n// stores the dimensions of the drivetrain\n#define CHASSIS_TRACK                                                          \\\n  14.25_in // distance between the inside edge of wheels on the same axle\n#define CHASSIS_WHEELS 3.25_in // diameter of drivetrain wheels\n// stores ports of the pistons used for the PTO mech\n#define LEFT_DIGITAL_SENSOR_PORT 'A'\n#define RIGHT_DIGITAL_SENSOR_PORT 'B'\n// stores port of the piston used for catapult\n#define CATAPULT_DIGITAL_SENSOR_PORT 'C' //TODO: remove all code to do with catapult piston\n// stores port of the piston used for extension\n#define EXTENSION_DIGITAL_SENSOR_PORT 'D'\n// stores port of the pullback limit switch\n#define PULLLIMIT_DIGITAL_SENSOR_PORT 'H'\n// okapilib\nextern std::shared_ptr&lt;okapi::Controller&gt;\nokapiController; // okapilib controller\nextern std::shared_ptr&lt;okapi::OdomChassisController&gt;\nchassis;                       // okapilib odometry controller\nextern okapi::MotorGroup okapiLDM; // drivetrain left motor group\nextern okapi::MotorGroup okapiRDM; // drivetrain right motor group\n#define OKAPI_DRIVE_MEASURE okapi::AbstractMotor::encoderUnits::degrees\n// pros\n#define PROS_DRIVE_GEARSET pros::E_MOTOR_GEAR_BLUE // blue motor (600rpm)\n#define PROS_DRIVE_MEASURE                                                     \\\n  pros::E_MOTOR_ENCODER_DEGREES // encoder measures in degrees\n// pros object declarations\nextern pros::Controller prosController; // pros contorller\n// declares pto motors\nextern pros::Motor lUFM; // left upper front motor\nextern pros::Motor rUFM; // right upper front motor\n// declares other motors\nextern pros::Motor rUBM; // right upper back motor\nextern pros::Motor lUBM; // left upper back motor\nextern pros::Motor rLFM; // right lower front motor\nextern pros::Motor lLFM; // left lower front motor\nextern pros::Motor rLBM; // right lower back motor\nextern pros::Motor lLBM; // left lower back motor\n// declare motor groups\nextern pros::Motor_Group prosLDM; // pros left drive motors\nextern pros::Motor_Group prosRDM; // pros right drive motors\n// declare pneumatic pistons\nextern pros::ADIDigitalOut leftPiston;   // left PTO piston\nextern pros::ADIDigitalOut rightPiston;  // right PTO piston\nextern pros::ADIDigitalOut catapultLock; // catapult piston\nextern pros::ADIDigitalOut jerry;        // extension piston\n// declare windback limit switch\nextern pros::ADIDigitalIn windbackLimit;\n// makes ptoActivated a global variable\nextern bool ptoActivated;\nextern bool extensionActivated;\nextern bool windingBack;\nextern bool intakeActivated;\n</code></pre> <p>Note</p> <p>Variables are stored here primarily for readability purposes throughout the codebase, although it also enables modularity through the use of global variables.</p> <p>This file contains the variable definitions used in the odometry controller constructor in main.cpp.</p> <p>We utilized global objects at the bottom of the file for modularity, allowing for multiple files to utilize the same objects.</p> <pre><code>graph LR\nA[#include] --&gt; B{Already included?};\nB ---&gt;|Yes| C(Ignore);\nB ---&gt;|No| D(Include);\nC --&gt; E(No double inclusion);</code></pre> <p>Info</p> <p><code>#pragma</code> serves as way to give the compiler a configuration setting before compiling the program.</p> <p>This chart illustrates the importance of the use of <code>#pragma once</code> at the beginning of the header file.</p> <p><code>#pragma once</code> acts very similarly to a <code>#ifndef</code> header guard.</p> <pre><code>graph LR\nA(Header file)\nB(File A)\nC(File B)\nD[#pragma once in header file]\n%%E(Header only included once)\nA --&gt;|#include| B;\nB --&gt;|#include| D;\nA --&gt;|#include| C;\nC --&gt; E;\nD --&gt;|Header not included again| C;\nE --&gt; F(No double inclusion);</code></pre> functions.cpp<pre><code>#include \"pros/adi.h\"\n#include \"robot.hpp\"\n// toggles the PTO mechanism\nvoid toggle_pto() {\n// if controller's front right bumper is pressed, toggles the PTO mechanism\nif (prosController.get_digital_new_press(pros::E_CONTROLLER_DIGITAL_X)) {\nptoActivated = !ptoActivated;\nrightPiston.set_value(ptoActivated);\nleftPiston.set_value(ptoActivated);\n}\n}\n/* utility function to shorten code\n * sets the speed of the pto motors.\n * @param speed The speed that the PTO motors will be set to.\n * 127 to -127\n */\nvoid set_ptom_speed(int speed) {\nlUFM = speed;\nrUFM = speed;\n}\nvoid update_controller() {\nstd::string on = \"t\";\nstd::string off = \"f\";\nconst char *onValue = on.c_str();\nconst char *offValue = off.c_str();\nif (ptoActivated) {\nprosController.print(0, 3, onValue);\n} else {\nprosController.print(0, 3, offValue);\n}\n}\n// the set of controls used when the PTO is activated\nvoid pto_controls() {\n// if the PTO is activated, check for a controller input to move the motors\n// attached to the PTO, otherwise, don't move motors\n// Input logic\nif (prosController.get_digital_new_press(\npros::E_CONTROLLER_DIGITAL_R2)) { // check if r2 has been pressed\nwindingBack = true; // update value, user wants to windback catapult\n}\nif (prosController.get_digital_new_press(pros::E_CONTROLLER_DIGITAL_L1)) {\nintakeActivated = !intakeActivated;\n}\npros::delay(300);\n// activation logic\nif (!ptoActivated) { // check if PTO is engaged into windback/intake mode\nif (windingBack &amp;&amp;\n!windbackLimit\n.get_new_press()) { // check if the user wants to windback the\n// catapult and if the catapult cant be wound\nset_ptom_speed(127);       // windback the catapult\n} else {\nif (intakeActivated) {\nset_ptom_speed(-127);\n} else {\nset_ptom_speed(0);\n}\nwindingBack = false;\n}\n}\n}\nvoid extension() {\nif (prosController.get_digital_new_press(pros::E_CONTROLLER_DIGITAL_A)) {\njerry.set_value(!extensionActivated);\nextensionActivated = !extensionActivated;\n}\n}\n// only rumbles once to not annoy the driver\nbool firstRumble = true;\n// array of motors to iterate through.\npros::Motor motors[8] = {rLFM, rLBM, rUFM, rUBM, lLFM, lLBM, lUFM, lUBM};\nvoid temp_rumble() {\nif (firstRumble) {\nfor (int i = 0; i &lt; sizeof(motors); i++) {\nif (motors[i].get_temperature() &gt; 40) {\nfirstRumble = false;\nprosController.rumble(\"...\");\nbreak;\n}\n}\n}\n}\n// function to actuate drivetrain. uses 6 vs 8 motors depending on status of\n// pto.\nvoid update_drivetrain() {\n/* if (ptoActivated) {\n     lUFM = prosController.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);\n     rUFM = prosController.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_Y);\n   } */\nprosLDM = prosController.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);\nprosRDM = prosController.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_Y);\n}\n// function to actuate the roller mech. uses up and down arrows to spin the\n// roller mech\nvoid roll_roller() {\nlUFM = 100 * (prosController.get_digital(pros::E_CONTROLLER_DIGITAL_UP) -\nprosController.get_digital(pros::E_CONTROLLER_DIGITAL_DOWN));\n}\n</code></pre> functions.hpp<pre><code>#pragma once // explanation under robot.h\n// functions in functions.cpp\nvoid toggle_pto();\nvoid pto_controls();\nvoid extension();\nvoid temp_rumble();\nvoid update_drivetrain();\nvoid update_controller();\nvoid roll_roller();\n</code></pre>"},{"location":"github/","title":"GitHub","text":"<p>Due to the fact that our team utilized PROS and has multiple developers, the implementation of a version control system was imperative. This is what led us to use GitHub, arguably the most universally recognized method of version control used by developers across the world.</p> <p>Our team utilized GitHub in order to allow multiple people to work on the program, as well as to host this website that you are reading from right now.</p> <p>We used two branches, one for the main program and one to build the website on. We utilized GitHub actions in order to build our website on each commit, allowing for us to change the website easily.</p> <p>This website was built using the Material for MkDocs theme, one of the many themes used for program documentation.</p>"}]}